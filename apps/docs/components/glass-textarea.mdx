---
title: Glass Textarea
description: Elegant multi-line text input component with Apple-inspired liquid glass effects and auto-resize functionality.
---

;
;

### Example

```tsx
export default function Demo() {
  const [message, setMessage] = useState("");
  const [feedback, setFeedback] = useState(
    "This component looks amazing! The liquid glass effects really make it stand out.",
  );
  const [notes, setNotes] = useState("");

  return (
    <div className="space-y-6 max-w-lg mx-auto">
      <div>
        <GlassTextarea
          label="Message"
          placeholder="Type your message here..."
          value={message}
          onChange={setMessage}
          maxLength={500}
          showCharacterCount
          helperText="Share your thoughts with us"
        />
      </div>

      <div>
        <GlassTextarea
          label="Feedback"
          description="Tell us what you think about this component"
          value={feedback}
          onChange={setFeedback}
          size="lg"
          minRows={4}
          maxRows={8}
          showCharacterCount
          characterCountPosition="bottom-left"
        />
      </div>

      <div>
        <GlassTextarea
          label="Quick Notes"
          placeholder="Jot down some notes..."
          value={notes}
          onChange={setNotes}
          size="sm"
          autoResize={false}
          minRows={2}
        />
      </div>

      <div className="p-4 rounded-lg bg-liquid-bg/5 border border-liquid-highlight/10">
        <h3 className="font-medium text-liquid-text-inverse mb-2">Character Counts:</h3>
        <div className="text-liquid-text-inverse/70 text-sm space-y-1">
          <p>Message: {message.length}/500</p>
          <p>Feedback: {feedback.length}</p>
          <p>Notes: {notes.length}</p>
        </div>
      </div>
    </div>
  );
}
```

## Overview

The Glass Textarea component provides an elegant multi-line text input interface with Apple-inspired liquid glass effects. It features auto-resize functionality, character counting, and comprehensive customization options.

## Props

| Prop                     | Type                              | Default          | Description                       |
| ------------------------ | --------------------------------- | ---------------- | --------------------------------- |
| `value`                  | `string`                          | -                | Current text value                |
| `defaultValue`           | `string`                          | -                | Default text value (uncontrolled) |
| `onChange`               | `(value: string) => void`         | -                | Callback when text changes        |
| `placeholder`            | `string`                          | -                | Placeholder text                  |
| `disabled`               | `boolean`                         | `false`          | Disabled state                    |
| `error`                  | `boolean`                         | `false`          | Error state                       |
| `helperText`             | `string`                          | -                | Helper text below textarea        |
| `label`                  | `string`                          | -                | Textarea label                    |
| `description`            | `string`                          | -                | Textarea description              |
| `autoResize`             | `boolean`                         | `true`           | Enable auto-resize functionality  |
| `minRows`                | `number`                          | `3`              | Minimum number of rows            |
| `maxRows`                | `number`                          | `10`             | Maximum number of rows            |
| `maxLength`              | `number`                          | -                | Maximum character limit           |
| `showCharacterCount`     | `boolean`                         | `false`          | Show character counter            |
| `characterCountPosition` | `'bottom-right' \| 'bottom-left'` | `'bottom-right'` | Position of character counter     |
| `size`                   | `'sm' \| 'md' \| 'lg'`            | `'md'`           | Size variant                      |

## Usage Patterns

### Basic Textarea

```tsx
const [text, setText] = useState('')

<GlassTextarea
  label="Description"
  placeholder="Enter description..."
  value={text}
  onChange={setText}
/>
```

### With Character Limit

```tsx
<GlassTextarea
  label="Bio"
  placeholder="Tell us about yourself..."
  value={bio}
  onChange={setBio}
  maxLength={280}
  showCharacterCount
  helperText="Keep it concise and engaging"
/>
```

### Fixed Height (No Auto-resize)

```tsx
<GlassTextarea
  label="Code Snippet"
  placeholder="Paste your code here..."
  value={code}
  onChange={setCode}
  autoResize={false}
  minRows={10}
  className="font-mono"
/>
```

### Form Integration

```tsx
const [formData, setFormData] = useState({
  title: "",
  description: "",
  notes: "",
});

const [errors, setErrors] = useState({});

const validateDescription = (value) => {
  if (!value.trim()) {
    return "Description is required";
  }
  if (value.length < 10) {
    return "Description must be at least 10 characters";
  }
  return "";
};

const handleDescriptionChange = (value) => {
  setFormData((prev) => ({ ...prev, description: value }));

  const error = validateDescription(value);
  setErrors((prev) => ({ ...prev, description: error }));
};

<form className="space-y-4">
  <input
    type="text"
    placeholder="Title"
    value={formData.title}
    onChange={(e) =>
      setFormData((prev) => ({ ...prev, title: e.target.value }))
    }
    className="w-full px-4 py-2 rounded-lg bg-liquid-bg/10 text-liquid-text-inverse"
  />

  <GlassTextarea
    label="Description"
    description="Provide a detailed description"
    value={formData.description}
    onChange={handleDescriptionChange}
    error={!!errors.description}
    helperText={errors.description || "Minimum 10 characters"}
    maxLength={1000}
    showCharacterCount
    required
  />

  <GlassTextarea
    label="Additional Notes"
    placeholder="Any additional information..."
    value={formData.notes}
    onChange={(value) => setFormData((prev) => ({ ...prev, notes: value }))}
    size="sm"
    minRows={2}
    maxRows={4}
  />
</form>;
```

### Rich Text Scenarios

```tsx
const [content, setContent] = useState("");
const [wordCount, setWordCount] = useState(0);

const handleContentChange = (value) => {
  setContent(value);

  // Calculate word count
  const words = value
    .trim()
    .split(/\s+/)
    .filter((word) => word.length > 0);
  setWordCount(words.length);
};

<div>
  <GlassTextarea
    label="Article Content"
    description="Write your article content here"
    value={content}
    onChange={handleContentChange}
    minRows={8}
    maxRows={20}
    showCharacterCount
    characterCountPosition="bottom-left"
  />

  <div className="mt-2 text-sm text-liquid-text-inverse/60">
    Words: {wordCount} | Estimated reading time: {Math.ceil(wordCount / 200)}{" "}
    min
  </div>
</div>;
```

### Auto-Save Implementation

```tsx
const [content, setContent] = useState("");
const [lastSaved, setLastSaved] = useState(null);
const [saving, setSaving] = useState(false);

const debouncedSave = useMemo(
  () =>
    debounce(async (value) => {
      setSaving(true);
      try {
        await saveContent(value);
        setLastSaved(new Date());
      } catch (error) {
        console.error("Save failed:", error);
      } finally {
        setSaving(false);
      }
    }, 1000),
  [],
);

const handleChange = (value) => {
  setContent(value);
  debouncedSave(value);
};

<div>
  <GlassTextarea
    label="Document"
    value={content}
    onChange={handleChange}
    placeholder="Start writing..."
    minRows={10}
  />

  <div className="mt-2 text-xs text-liquid-text-inverse/50">
    {saving
      ? "Saving..."
      : lastSaved
        ? `Last saved: ${lastSaved.toLocaleTimeString()}`
        : "Not saved"}
  </div>
</div>;
```

## Accessibility

### WCAG Compliance

- **Keyboard Navigation**: Full keyboard support for text editing
- **Screen Readers**: Proper labels, descriptions, and character count announcements
- **Focus Management**: Clear focus indicators and proper tab order
- **Error Handling**: Accessible error messages and validation feedback

### Implementation Details

- Uses semantic `<textarea>` element with proper labeling
- Character count is announced to screen readers
- Error messages are associated with the textarea
- Required state is communicated to assistive technologies
- Auto-resize maintains accessibility during height changes

### Keyboard Support

| Key            | Action                       |
| -------------- | ---------------------------- |
| `Tab`          | Navigate to next element     |
| `Shift + Tab`  | Navigate to previous element |
| `Ctrl/Cmd + A` | Select all text              |
| `Ctrl/Cmd + Z` | Undo                         |
| `Ctrl/Cmd + Y` | Redo                         |
| `Enter`        | New line                     |

## Apple HIG Guidelines

### Visual Design

- **Liquid Glass Effects**: Multi-layered transparency with backdrop blur
- **Typography**: SF Pro font family with appropriate line height
- **Spacing**: Consistent padding and margin using 8pt grid
- **Resize Behavior**: Smooth auto-resize animations

### Interaction Patterns

- **Immediate Feedback**: Real-time character counting and validation
- **Smooth Animations**: Gentle transitions for height changes
- **Touch-Friendly**: Appropriate touch targets and scroll behavior
- **Error Prevention**: Clear constraints and helpful guidance

### Layout Principles

- **Flexible Height**: Auto-resize adapts to content length
- **Consistent Alignment**: Text aligns properly with other form elements
- **Responsive Design**: Adapts to different screen sizes
- **Content Hierarchy**: Clear visual hierarchy with labels and descriptions

### Content Guidelines

- **Placeholder Text**: Helpful, actionable placeholder text
- **Character Limits**: Clear indication of limits and remaining characters
- **Helper Text**: Contextual guidance for users
- **Error Messages**: Clear, actionable error messaging

## Best Practices

### Performance

- Use `React.memo` for components with stable props
- Debounce auto-save functionality to prevent excessive API calls
- Optimize auto-resize calculations for smooth performance
- Implement efficient character counting

```tsx
// Optimized character counting
const useCharacterCount = (text, maxLength) => {
  return useMemo(() => {
    const count = text.length;
    const remaining = maxLength ? maxLength - count : null;
    const isOverLimit = maxLength ? count > maxLength : false;

    return { count, remaining, isOverLimit };
  }, [text, maxLength]);
};

// Debounced auto-resize
const useDebouncedResize = (callback, delay) => {
  const debouncedCallback = useMemo(
    () => debounce(callback, delay),
    [callback, delay],
  );

  return debouncedCallback;
};
```

### UX Guidelines

- Provide clear labels and helpful placeholder text
- Use appropriate minimum and maximum row constraints
- Implement smart auto-resize that doesn't jump unexpectedly
- Show character counts for limited-length inputs

### Validation and Error Handling

```tsx
const validateTextarea = (value, required, minLength, maxLength) => {
  const errors = [];

  if (required && !value.trim()) {
    errors.push("This field is required");
  }

  if (minLength && value.length < minLength) {
    errors.push(`Minimum ${minLength} characters required`);
  }

  if (maxLength && value.length > maxLength) {
    errors.push(`Maximum ${maxLength} characters allowed`);
  }

  return errors;
};

const handleTextChange = (newValue) => {
  const errors = validateTextarea(newValue, required, minLength, maxLength);

  if (errors.length > 0) {
    setError(errors[0]);
  } else {
    setError("");
    onChange(newValue);
  }
};
```

### Mobile Considerations

- Ensure textarea is properly sized for mobile viewports
- Test auto-resize behavior on various mobile browsers
- Consider virtual keyboard behavior and viewport changes
- Optimize touch scrolling within the textarea

```tsx
const isMobile = useMediaQuery("(max-width: 768px)");

const textareaProps = {
  ...props,
  ...(isMobile && {
    rows: Math.max(minRows, 4), // Larger minimum on mobile
    style: {
      ...props.style,
      fontSize: "16px", // Prevent zoom on iOS
    },
  }),
};
```

### Auto-Resize Implementation

```tsx
// Custom hook for auto-resize functionality
const useAutoResize = (textareaRef, value, minRows, maxRows) => {
  const [height, setHeight] = useState("auto");

  useEffect(() => {
    if (!textareaRef.current) return;

    const textarea = textareaRef.current;
    const computedStyle = window.getComputedStyle(textarea);
    const lineHeight = parseInt(computedStyle.lineHeight, 10);
    const paddingTop = parseInt(computedStyle.paddingTop, 10);
    const paddingBottom = parseInt(computedStyle.paddingBottom, 10);
    const borderTop = parseInt(computedStyle.borderTopWidth, 10);
    const borderBottom = parseInt(computedStyle.borderBottomWidth, 10);

    // Reset height to calculate scroll height
    textarea.style.height = "auto";
    const scrollHeight = textarea.scrollHeight;

    // Calculate min and max heights
    const minHeight =
      minRows * lineHeight +
      paddingTop +
      paddingBottom +
      borderTop +
      borderBottom;
    const maxHeight =
      maxRows * lineHeight +
      paddingTop +
      paddingBottom +
      borderTop +
      borderBottom;

    // Set new height within constraints
    const newHeight = Math.min(Math.max(scrollHeight, minHeight), maxHeight);
    setHeight(`${newHeight}px`);
  }, [value, minRows, maxRows]);

  return height;
};
```

### State Management

```tsx
// Custom hook for textarea state
const useTextarea = (initialValue = "", options = {}) => {
  const [value, setValue] = useState(initialValue);
  const [error, setError] = useState("");
  const [focused, setFocused] = useState(false);

  const { maxLength, required, minLength } = options;

  const characterCount = useMemo(() => {
    const count = value.length;
    const remaining = maxLength ? maxLength - count : null;
    const isOverLimit = maxLength ? count > maxLength : false;

    return { count, remaining, isOverLimit };
  }, [value, maxLength]);

  const validate = useCallback(
    (val = value) => {
      const errors = validateTextarea(val, required, minLength, maxLength);
      const error = errors[0] || "";
      setError(error);
      return !error;
    },
    [value, required, minLength, maxLength],
  );

  const handleChange = useCallback(
    (newValue) => {
      setValue(newValue);
      validate(newValue);
    },
    [validate],
  );

  return {
    value,
    setValue: handleChange,
    error,
    focused,
    setFocused,
    characterCount,
    validate,
    isValid: !error,
  };
};
```
